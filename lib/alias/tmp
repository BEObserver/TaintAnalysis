
  /* //iterate through the map
     for (std::map<Instruction*, bool>::iterator iter_start = worklist.begin(),iter_end = worklist.end(); 
          iter_start != iter_end; ++iter_start) {
          //find the instruction refering the pointer value d;
          if () {
            if (const StoreInst *storetmp = dyn_cast<const StoreInst>(iter_start->first)) {
            } else {
            }  
          }

          if (const LoadInst *loadtemp = dyn_cast<const LoadInst>(iter_start->first)) {
              
            //check if the pointer operand to the current load instruction loads the parameter
            if ( ((loadtemp->getPointerOperand())->getName()).compare((*d).getName()) == 0 ) {
                
              //std::cout << "The Load Inst in Taint Analysis: " << std::endl;
              //loadtemp->dump();
             
              //set instruction as tainted
              iter_start->second = true;
            }
          }
        }
      }
    }
  }
  }
    
  std::vector<Instruction*>::iterator it;
  Instruction* current;
    
    //flag used to check for fixed point in the analysis - If flag is not set fixed point is reached
    bool exit_flag = false;
    
    //iterate through the instruction list until fixed point is reached or all instructions are tainted
    while (!worklist2.empty() && !exit_flag) {
        
      exit_flag=true;
        
      //iterate the instruction in the lex order
      for (it = instList.begin();it != instList.end(); ++it) {
        current = (*it);
        //found a tainted instruction
        if (worklist2.find(*it)->second == true) {
          //fixed point not reached
          exit_flag=false;
                
          //if the instruction is a store
          if (StoreInst *store = dyn_cast<StoreInst>(worklist2.find(*it)->first)) {

            //insert the tainted variable into the tainted list
            taintSet2.insert(store->getPointerOperand());
          } else if (Instruction* tempIns = dyn_cast<Instruction>(worklist2.find(*it)->first)) {
            //for all other instructions

            //iterate through the use def chain of the tainted instruction
            for (Value::use_iterator i_reg=(*tempIns).use_begin(),e_reg=(*tempIns).use_end();i_reg != e_reg; ++i_reg) {
                        
              if (Instruction *temp = dyn_cast<Instruction>(*i_reg)) {
                //mark the user of the tainted instruction as tainted

                worklist2.find(temp)->second = true;
                worklistParams.find(temp)->second = true;
              }
            }
          }
                
          //delete the instruction from the worklist
          worklist2.erase(worklist2.find(current));
        } else if (Instruction *someIns = dyn_cast<Instruction>(worklist2.find(*it)->first)) {
          //if the instruction is not tainted yet
          exit_flag = false;
                
          //see if the instruction has an alias pair which is tainted
          if (Instruction* ins = alias.getAliasPair(someIns)) {
                    
            std::set<Value*>::iterator temp_it;
                    
            //if the aliased pair is a load instruction and if it is tainted mark the current instruction as tainted
            if (LoadInst *loadIns = dyn_cast<LoadInst>(ins)) {

              if (taintSet2.find( loadIns->getPointerOperand() ) != taintSet2.end()) {
                            
                 worklist2.find(someIns)->second = true;
                 worklistParams.find(someIns)->second = true;
                            
                 if (StoreInst *store = dyn_cast<StoreInst>(someIns)) {
                   //add the current instruction to the taintset if its a store
                   taintSet2.insert(store->getPointerOperand());
                                
                 } else {
                   //if the current instruction is a non-store instruction iterate their use def chain
                   for (Value::use_iterator i_reg=(*someIns).use_begin(),e_reg=(*someIns).use_end(); i_reg != e_reg; ++i_reg) {
                                    
                     if (Instruction *temp = dyn_cast<Instruction>(*i_reg)) {
                       worklist2.find(temp)->second = true;
                       worklistParams.find(temp)->second = true;
                     }
                   }
                 }
               }
             }
           }
           worklist2.erase(worklist2.find(current));
         }
       }
     }
    
    taintSetGlobal = taintSet2; // input-tainted set 
    
    errs() << "parameter flow in function " << F.getName().str() << ":\n";
    
    std::set<Value*>::iterator temp_it;
    
    for (temp_it = taintSet2.begin(); temp_it != taintSet2.end(); ++temp_it)
        errs()<< (*temp_it)->getName() << "\n";
    
    threadid = 0;

    if (threadid) {
      Value *val = dyn_cast<Value>(threadid);
        
      for (Value::use_iterator i = val->use_begin(), e = val->use_end(); i != e; ++i) {
            
        for (inst_iterator newI = inst_begin(F), newE = inst_end(F); newI != newE; ++newI) {
                
          if (Instruction* ins = dyn_cast<Instruction>(&*newI)) {
            if (worklist.find(&*newI) == worklist.end() ) {
              worklist.insert(std::pair<Instruction*,bool>(ins,false));
              worklistTC.insert(std::pair<Instruction*,bool>(ins,false));
            }
          }
                
          if (LoadInst * load= dyn_cast<LoadInst>(&*newI)) {
            //true because the global value should be loaded
            if (load->getPointerOperand() == *i) {
              worklist[&*newI] = true;
              worklistTC[&*newI] = true;
            }
          }
        }
      }
        
      std::vector<Instruction*>::iterator it;
      bool exit_flag = false;
      Instruction* current;
        
      while (!worklist.empty() && !exit_flag) {
        //Marking Sink as Tainted
        exit_flag=true;
        for (it = instList.begin();it != instList.end(); ++it) {
          current = (*it);
          if (worklist.find(*it)->second == true) {
            exit_flag=false;
            if (StoreInst *store = dyn_cast<StoreInst>(worklist.find(*it)->first)) {
              taintSet.insert(store->getPointerOperand());
            } else if (Instruction* tempIns = dyn_cast<Instruction>(worklist.find(*it)->first)) {
              for (Value::use_iterator i_reg=(*tempIns).use_begin(),e_reg=(*tempIns).use_end();i_reg != e_reg; ++i_reg) {
                if (Instruction *temp = dyn_cast<Instruction>(*i_reg)) {
                  worklist.find(temp)->second=true;
                  worklistTC.find(temp)->second=true;
                }
              }
            }
                    
            worklist.erase(worklist.find(current));
          } else if (Instruction *someIns = dyn_cast<Instruction>(worklist.find(*it)->first)) {
            exit_flag = false;
            if (Instruction* ins = alias.getAliasPair(someIns)) {
              std::set<Value*>::iterator temp_it;
                        
              if (dyn_cast<LoadInst>(ins))
                if (taintSet.find( dyn_cast<LoadInst>(ins)->getPointerOperand() ) != taintSet.end()) {
                  worklist.find(someIns)->second=true;
                  worklistTC.find(someIns)->second=true;
                  if (StoreInst *store = dyn_cast<StoreInst>(someIns)) {
                    taintSet.insert(store->getPointerOperand());
                  } else {
                    for (Value::use_iterator i_reg=(*someIns).use_begin(),e_reg=(*someIns).use_end();i_reg != e_reg; ++i_reg) {
                      if (Instruction *temp = dyn_cast<Instruction>(*i_reg)) {
                        worklist.find(temp)->second=true;
                        worklistTC.find(temp)->second=true;
                      }
                    }
                  }
                }
              }
              worklist.erase(worklist.find(current));
            }
          }
	}
       
        
        //global data structure to prevent over-writing of function pass locals
        taintSetGlobal2 = taintSet; // threadid-tainted set 
        
        if (taintSet.size() > 0)
          errs() <<"thread id flow" << "\n";
        
        std::set<Value*>::iterator temp_it;
        
        for (temp_it = taintSet.begin(); temp_it != taintSet.end(); ++temp_it)
          errs() << (*temp_it)->getName() << "\n";
    } else {
      errs()<<"No thread dependents";
    }*/
    
